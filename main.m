%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
close all
clear all
%% This is the main frame work of the analysis. 
% (For a summary of how the code works and the math behind the formulas,
% please read the accompagnying README document.)
% It will use the files generated by JVTItxttomat and extractedResistance, 
% to give as a final output the aerial generation rate, the mu-tau product, 
% and the best guess for the mu and tau separately.
% Even though srv (surface recombination velocity) is included here, the
% first model (solver1) doesn't take srv into account and the second
% model's (solver2) current simplification to solving the differential
% equation including diffusion has srv = 0 to get simple boundary
% conditions. This can be changed in the future iterations of the code.
% There are two ways to approach this code: 
% 1/ using one specific temperature data set, look at the behavior of the
% sample in full dark and full light illumination.
    % RECOMMENDED to see the output of the code in a first instance, which
    % is 4 files, 1 mat file (geometric constants) and 3 plots
    % To do so, simply extract only 1 temperature and 1 illumination before
    % the loop.
    
% 2/ having taken a range of temperatures and illuminations, loop
% through all the data sets. The 5 files are named with the temperature and
% illumination of the data set used, and are placed in a generated folder
% for the specific sample. The 5th file is a summary txt file of the
% illumination, temperature, and corresponding mu, tau and srv values.
    % Right now, the code is set up for this version.

% These are the global variables used in main, optimizedParameters and
% other functions called into this code.
global s t L N Rlightfilter Rdark e h c depth Gwave Nmu Ntau Nsrv T k q
global muTauVsRMSPlot muTauVsRlightPlot contourPlot
    
% Here is the inputs specific to the set-up/experiment:
s = 7.22e-3 ;% length of the snake, m
t = 1e-6; % thickness of the cell, m (for both GaAs and SnS)
L = 750e-6; % finger spacing, m

% Hard coded constants:
e = 1.6e-19; % Coulombs
h = 6.626 * 10^-34; % JÂ·s
c = 2.998 * 10^8; % m/s
k = 1.380e-23; % J/K = CV/K
q = 1.602e-19; %C

%Code values recomment
N = 5000; % number of slabs (number of points taken), unitless. For best accuracy
% this value was increased until the final result no longer varied (can be
% seen in Lenahan's thesis). This N value should be verified for other data
% samples.

% For the initial guesses, the ranges can be determined here. These are
% purposefully very wide ranges in SI units.
tauRange = [1e-10,0.01];%s
srvRange = [1,1e5];%unitless
mobRange = [1e-10,0.01];%m^2/(Vs)
% Number of grid points to take within a range of values for tau, srv, mu
% to best fit each value.
Ntau = 5; Nsrv = 5; Nmu = 5;

%% First, the energy flux and absorption coefficients in terms of wavelength
% need to be extracted from the data for the future calculation of G.

% For the absorption coefficient data, the data is taken from:
absorptionCoefficientData = dlmread('240C_absorption.abs');

% From this, the generation rate is established, with its absorption
% coefficient and photon flux dependence on wavelength.
%The available data (ASTMG173.csv) is in terms of (W/(m^2*nm)), so there
%is already a wavelength dependence for the energy flux.

% The following lines cut the file down to where the data is being taken
% every wavelength (making the difference between two lines be -1). After
% generating this new list, the list is cut down to every 5th wavelength.
lightSpectrumInfo = csvread('ASTMG173.csv',2,0);%this reads the txt file with four columns
for iLight=1:length(lightSpectrumInfo)-1
    difference(iLight) = lightSpectrumInfo(iLight,1) - lightSpectrumInfo(iLight+1,1);
end
% here we're looking for the row numbers starting and ending the
% 1-wavelength interval section
firstLight = find(difference' == -1,1);
lastLight = find(difference' == -1,1,'last')+1;
% now we can get every 5th wavelength
wavelengthLight = lightSpectrumInfo(firstLight:5:lastLight,1).*1e-9; 
% the units were changed to m by multiplying by 1e-9
% We can similarly set up the energy flux data in the 4th column (in W/m^3):
energyFluxDensityData = lightSpectrumInfo(firstLight:5:lastLight,4).*1e9;

newLightSpectrum = [wavelengthLight energyFluxDensityData];%make a new table

% To visualize the data, this can be uncommented.
%figure, plot(newLightSpectrum(:,1),newLightSpectrum(:,2));

% Now the energy flux is within the wanted range with a dependence on
% regular interval wavelengths.

% For the absorption coefficient, the measurement data (already
% called as variable absorptionCoefficientData) can be used
wavelength = absorptionCoefficientData(:,1).*1e-9;
absCoeff = absorptionCoefficientData(:,2)*1e2;% absorption coefficient, dependent on wavelength, 1/m

% The two data files have the same incremenent size.
% However, the ranges covered are not the same, so let's find the first and
% last common values:
first = find(wavelengthLight == wavelength(1,1));
lastValue = find(wavelength,1,'last');
cutOff=find(newLightSpectrum==wavelength(lastValue,1));
fullEnergyFlux = newLightSpectrum(first:cutOff,:);
%% Data analysis
% To extract the filtered light and dark resistances from the actual data,
% the two programs written by Lenahan can be used: JVTItxttomat (which
% transcribes the txt files to the mat file format) and
% extractedResistance which does the actual analysis. These files
% can be modified to output plots and other information on the data.

% First, the sample name associated to the data files is needed: this is the
% name up until _IVTraw.
name = input('What is the sample name? ', 's');
% 
% Then Lenahan's code is called.
if isempty(strfind(name, '_')) == 1
    %this means that there is no _ in the name
    JVTItxttomat_v6(name)
    disp('name')
else JVTItxttomat_v5_SnSoDarkAndFilters(name)
    disp('underscore')
end
% This file analyzes the JTVI data and makes a summary file.

extractedResistance_v4_forv5(name)
% This file extracts the light and dark resistances.To read the file, we 
% need to give the correct pathway.
path = 'DataAnalysis/';
% load sample as a 
sample = load([path name '_summary.mat']);
% This file contains the information for a range of temperatures and
% illuminations, so several things can be done: either consider only the
% light and dark cases to observe the overall behavior of the material for
% a specific temeperature, which is considered the simplified version here,
% or consider all of the temperatures and illuminations and vary them
% iteratively to get a complete sense of the data.
temperature = sample.T;
Tn = length(sample.T);
illumination = sample.ill;
In = length(sample.ill);
% For the simplified version, instead of taking all of sample.T and
% sample.ill, take sample.T(number) and sample.ill(number) and apply this
% also in Tn and In. The loop will still work.

% For the iterative version, there are several things that need to be done.
% Such that the text file can be populated in a orderly manner, the
% iteration count (or itcount) needs to be initialized. This will be
% equivalent to the the row number of each iteration result.
itcount = 0;
% Then, from the summary file the illumination vector is extracted.
% Those values are the indices of the illumination percentages in the
% G_ODpercent row vector.
G_ODpercent = [0,1.25,0.365,0.107,0.0200,0.0032,0.000647,1.12,0.329,0.0967,0.0181,0.00289,0.00059,0.834,0.245,0.0716,0.0134,0.00214,0.000446,0.617,0.184,0.0548,0.0103,0.00165,0.000351,0.506,0.153,0.0457,0.00857,0.00138,0.0003,0.296,0.0887,0.0268,0.00499,0.000819,0.000195];

% All of the figures generated will be saved to the following folder.
mkdir(['FiguresFor' name]);

for iT=1:Tn
    specificT = temperature(iT);
    T = round(specificT*100,0);
    Tindex = find(temperature == specificT);
    for iI = 2:In % starting from 2 to avoid dark/dark comparison
        itcount = itcount+1;
        specificIll = illumination(iI);
        Iindex = find(illumination == specificIll);
        illPercent = G_ODpercent(specificIll) ;
        Rlightfilter = sample.RList(Tindex,Iindex);%ohms
        Rdark = sample.RList(Tindex,1); %ohms
        if Rdark == 0 
            Rdark = 1
            %There is a division where Rdark is on the denominator, so
            %Rdark cannot be 0. This can be replaced by another value if
            %needed.
        end
       
        % These can be called from the text file as matrix entries.
        
        % Now the associated energy flux data can be populated, with the
        % wavelengths in the first column and the energy flux considering
        % the filter in the second column.
        newEnergyFlux = [fullEnergyFlux(:,1) fullEnergyFlux(:,2)*illPercent];
        % newEnergyFlux is then the new variable with appropriate range of the
        % light spectrum covered by the measurement.

        %% Calculating the aerial generation rate and experimental mu-tau product
        % In a first instance, the generation rate is considered to depend on the
        % wavelength, so the following integration takes place:

        depth = linspace(0,t,N)';
        % This takes the depth of the material and separates into N slices, for an
        % easier time computing later on (see diagram in accompagnying document).
        photonFlux = (newEnergyFlux(:,1) ./ (h .*c)) .* newEnergyFlux(:,2);
        %a reminder that newEnergyFlux(:,1) is the wavelength.

        % here for every value of depth, the generation rate is integrated over the
        % measured spectrum of light (Gwave: G with dependence on wavelength).
        for i=1:N
            Gwave(i) = trapz(newEnergyFlux(:,1), absCoeff .* photonFlux .* exp(-absCoeff .* depth(i)));
        end
        % a new Nx2 matrix for depth and G wave is made.
        [depth Gwave'];

        % Now the areal generation rate can be calculated in terms of the depth of
        % the material.
        global G
        G = trapz(depth,Gwave)

        % The specifics of the following derivation can be found in the adjoined
        % document, but the mu-tau product should follow from this formula:

        global muTauProduct
        muTauProduct = L./(e.*s .* G).*(1./Rlightfilter - 1./Rdark) % in m^2/V

        %% Modeling to fit for mobility and lifetime values
        % These two calculations, G and muTauProduct, can now be considered as the 
        % base for an iterative processes to find better estimations of the
        % individual values of each wanted variable. 

        % Using Brandt's code for optimizing three parameters, tau, srv, and mu
        % guesses are tested iteratively by trying to minimize the difference
        % between the Rlight that was gained experimentally and the Rlight that can
        % be calculated from the mu and tau values.

        % Initially, the range is determined by the user, as can be seen above at
        % the beginning of the code. From those end points, we can determine the
        % step of the lists (Ntau/srv/mu).

        tauRangeStep = tauRange(1):(tauRange(2)-tauRange(1))/Ntau:tauRange(2);
        srvRangeStep= srvRange(1):(srvRange(2)-srvRange(1))/Nsrv:srvRange(2);
        mobRangeStep = mobRange(1):(mobRange(2)-mobRange(1))/Nmu:mobRange(2);

        % Working the adjoining file optimizeParameters.m, the variables are found
        % by running N_max simulations and choosing the "best" values by taking the
        % smallest difference with Rlight.
        % Define how many simulations will be run before the range is
        % redefined
        N_max = 3000;
        % How many "best fits" will be saved each time
        N_store = 50;

        % This is just to save the best parameters -- it'll be N_store x 3
        L_store = zeros(N_store,3);
        % Here the error for each fit can be stored, so the fit can be checked
        % (each entry maps to a set of parameters in L_store)
        RMS_store = zeros(N_store,1);

        % The resulting best fits are generated by optimizeParameters.
        [bestTau bestSRV bestMu] = optimizeParameters(tauRange,srvRange,mobRange,N_max,N_store);

        % For the following calculations, some matrices need to be initialized.
             depthTau = linspace(0,t,Ntau+1)';
             deltaR = zeros(Ntau,Nsrv,Nmu);
             rLightMatrix = zeros(Ntau,Nsrv,Nmu);
             deltaN = cell(Ntau,Nsrv,Nmu);

        % Having an approximation of the best fits for tau, mu, and srv, one
        % still wants to see how the resulting Rlights differ from the
        % experimental Rlight. Here either solver1 or solver2 can be run
        % for the modelling sequence.

        for  ii=1:length(tauRangeStep)
            for jj=1:length(srvRangeStep)
                for kk=1:length(mobRangeStep)
                    % deltaN is now a matrix with vectors for each entry
                    % For the model only considering depth-dependence of
                    % the charge carrier generation, use solver1.
                    deltaN{ii,jj,kk} = solver1(tauRangeStep(ii));
                    
                    % For the model also considering diffusion of charge carriers, 
                    % use solver2
                    %deltaN{ii,jj,kk}=solver2(0,t,5001,mobRangeStep(kk),tauRangeStep(ii));
                    % where 5001 is the number of gridpoints N+1
                     
                    rLightMatrix(ii,jj,kk) = calculateRlight(deltaN{ii,jj,kk},mobRangeStep(kk));
                    
                    % here the matrix of calculated Rlight is generated.
                    deltaR(ii,jj,kk) = rLightMatrix(ii,jj,kk) - Rlightfilter;
                    % here the difference between the two is calculated.
                end
            end
        end
        
        % The different matrices can be generated, but since these are 3D it would
        % be inconvenient for them to print. Instead let them be plotted.
            deltaN;
            rLightMatrix;
            deltaR;
        % Two figures are generated in optimize parameters, here are only
        % the contour plots.
        if isequal(squeeze(deltaR(:,1,:)),zeros(Ntau)) == 1
            warning(['Null value so contour plot is not possible'])
            %Contour plots require at least two non-null values.
        else
            contourPlot = figure(3);
                    subplot(1,2,1)
                contourf(mobRangeStep*10^4,tauRangeStep,squeeze(deltaR(:,1,:)));colorbar
                xlabel('Mu value (in cm^2/(Vs))');ylabel('Tau value (in s)');
                title('deltaR for srv(1)')
                    subplot(1,2,2)
                 contourf(mobRangeStep*10^4,tauRangeStep,squeeze(abs(deltaR(:,2,:))));colorbar
                 title('Abs(deltaR) for srv(2)')
                 xlabel('Mu value (in cm^2/(Vs))');ylabel('Tau value (in s)');
        end
        % Now the range can be narrowed around the best values.
                    tauRange = [0.9*bestTau,1.1*bestTau];
                    srvRange = [0.9*bestSRV,1.1*bestSRV];
                    muRange = [0.9*bestMu,1.1*bestMu];
                    [bestTau bestSRV bestMu] = optimizeParameters(tauRange,srvRange,mobRange,N_max,N_store);

            % These are the final best values, and the mu-tau product associated.
            bestTau;
            bestSRV ;
            bestMu;
            bestMuTauProduct = bestTau * bestMu;

            deltaN;
            rLightMatrix;
            deltaR;
            
        table(itcount,:) = [T; illPercent; bestTau; bestSRV; bestMu];
        % This is the row for the summary table, which gets exported out to a
        % txt file which has a better precision (scientific notation).
        
        % Note the illumination percent that shows up here is the one taken
        % as "light" in the comparison.
        savefig(contourPlot,['FiguresFor' name '/' sprintf('contour_plot_for_T_%d_and_ill_%.4f.fig',T,illPercent)]);
        savefig(muTauVsRMSPlot,['FiguresFor' name '/' sprintf('muTau_RMS_plot_for_T_%d_and_ill_%.4f.fig',T,illPercent)]);
        savefig(muTauVsRlightPlot,['FiguresFor' name '/' sprintf('muTau_Rlight_plot_for_T_%d_and_ill_%.4f.fig',T,illPercent)]);
    end
end
table
nameOfFile = sprintf('geometric_constants_for_%s.mat',name);
%add the name of the solver
save(['FiguresFor' name '/' nameOfFile],'s','t','L','N');
tableName = ['FiguresFor' name '/summaryTable.txt']
fileID = fopen(tableName,'w');
fprintf(fileID,'%1s %16s %9s %10s %11s\n','T','illPercent','bestTau','bestSRV','bestMu');
fprintf(fileID,'%1.2f %11.2f %10.2e %10.2e %12.2e\n',table);
fclose(fileID);
